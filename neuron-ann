`timescale 1ns / 1ps


module neuron1 #(parameter N = 10)
                (input clk,rst,
                input [31:0] x,
                 output reg [31:0] out,
                 output reg done);

reg [31:0] W[0:(N-1)];
//reg [31:0] X[0:(N-1)];
reg [31:0] bias ;
reg [31:0] x_temp, w;
wire [31:0] out1, temp_out;
wire [31:0] relu_in;
//reg clr_in = 0;
//reg done=0;  // Changed wire to reg
integer i=0;

mac m1 (clk, w, x_temp, out1);
//assign relu_in = out1 + bias;
add_fp a3(out1,bias,relu_in);
ReLu m2 (relu_in, temp_out);

initial begin
     bias = 32'h3E800000; // 0.25
     W[0] = 32'h3E800000; // 0.25
     W[1] = 32'hBE800000; // -0.25
     W[2] = 32'h3F000000; // 0.5
     W[3] = 32'h3F400000; // 0.75
     W[4] = 32'h3F800000; // 1.0
     W[5] = 32'hBF000000; // -0.5
     W[6] = 32'hBF400000; // -0.75
     W[7] = 32'h3EAAAAAB; // 0.333
     W[8] = 32'hBEAAAAAB; // -0.333
     W[9] = 32'h3F19999A; // 0.6
end

// Sequential Logic for Data Feeding
always @(posedge clk) begin
    if(rst) 
    begin
    i<=0;
    x_temp<=0;
    w<=0;
    //out<=0;
    done<=0;
    end
    else begin
    if (!done) begin
        x_temp <= x;
        w <= W[i];
        i <= i + 1;
        end
    else begin
        x_temp<=0;
        w<=0;
    end
    end
    if (i == N-1) begin
        done <= 1'b1;  // Set done when i reaches N
        end
end

// Output Logic
always @(*) begin
    if (done)
        out = temp_out;
    else
        out = 32'd0;  // Clear output until calculations finish
end
endmodule
